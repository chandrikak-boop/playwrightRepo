"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSchemaZod = exports.validateSchemaAjv = exports.validateSchema = void 0;
const test_1 = require("@playwright/test");
const highlight_js_1 = __importDefault(require("highlight.js"));
const core_ajv_schema_validator_1 = require("core-ajv-schema-validator");
const core_zod_schema_validator_1 = require("core-zod-schema-validator");
// Obtain the version of highlight.js from package.json
const packageJSON = __importStar(require("../package.json"));
const hljsVersion = packageJSON['dependencies']['highlight.js'].replace(/[\^~]/g, '');
// ------------------------------------
// MESSAGE ICONS
// ------------------------------------
const iconPassed = '✔️';
const iconFailed = '❌';
const issuesStylesDefault = {
    iconPropertyError: '⚠️',
    colorPropertyError: '#d67e09',
    iconPropertyMissing: '❌',
    colorPropertyMissing: '#c10000'
};
const warningDisableSchemaValidation = `⚠️ API SCHEMA VALIDATION DISABLED ⚠️`;
const passResponseBodyAgainstSchema = `${iconPassed}   PASSED - THE RESPONSE BODY IS VALID AGAINST THE SCHEMA!`;
const errorResponseBodyAgainstSchema = `${iconFailed}   FAILED - THE RESPONSE BODY IS NOT VALID AGAINST THE SCHEMA!`;
const msgDisableSchemaValidation = 'The Playwright environment variable "DISABLE_SCHEMA_VALIDATION" has been set to true.';
// **********************************************************************
// PUBLIC API
// **********************************************************************
/**
 * Validates the response body against a given schema using Ajv.
 * Note that the function already asserts the validity of the schema, so there is no need to add additional assertions on the results.
 *
 * @param {object} fixtures - An object containing test fixtures, such as the page object: `{ page }`.
 * @param {object} data - The JSON data to validate against the schema.
 * @param {any} schema - The schema to validate against. Supported formats are plain JSON schema, Swagger, and OpenAPI documents. See https://ajv.js.org/json-schema.html for more information.
 * @param {object} [path] - The path object to the schema definition in a Swagger or OpenAPI document. Not required if the schema is a plain JSON schema.
 * @param {string} [path.endpoint] - The endpoint path. Required if the schema is a Swagger or OpenAPI document.
 * @param {string} [path.method="GET"] - The HTTP method (e.g., "GET", "POST") of the API request. Defaults to "GET".
 * @param {number} [path.status=200] - The expected status code of the API response. Defaults to 200.
 * @param {object} [issuesStyles] - Optional object with an override of the default icons and HEX colors used to flag the schema issues.
 * @param {string} [issuesStyles.iconPropertyError] - Custom icon to flag property errors.
 * @param {string} [issuesStyles.colorPropertyError] - Custom HEX color to flag property errors.
 * @param {string} [issuesStyles.iconPropertyMissing] - Custom icon to indicate missing properties.
 * @param {string} [issuesStyles.colorPropertyMissing] - Custom HEX color to indicate missing properties.
 *
 * @returns {Promise<object>} A Promise resolving to an object containing validation results:
 * - `errors`: An array of validation errors as provided by Ajv, or `null` if validation passes.
 * - `dataMismatches`: The original response data with all schema mismatches flagged directly.
 *
 */
const validateSchemaAjv = async (fixtures, data, schema, path, issuesStyles) => {
    return _validateSchema('ajv', fixtures, data, schema, path, issuesStyles);
};
exports.validateSchemaAjv = validateSchemaAjv;
/**
 * validateSchema() and validateSchemaAjv() are aliases for the same function.
 */
const validateSchema = validateSchemaAjv;
exports.validateSchema = validateSchema;
/**
 * Validates the response body against a given schema using Zod.
 * Note that the function already asserts the validity of the schema, so there is no need to add additional assertions on the results.
 *
 * @param {object} fixtures - An object containing test fixtures, such as the page object: `{ page }`.
 * @param {object} data - The JSON data to validate against the schema.
 * @param {any} schema - The schema to validate against. Supported formats are plain JSON schema, Swagger, and OpenAPI documents. See https://zod.dev/ for more information.

 * @param {object} [issuesStyles] - Optional object with an override of the default icons and HEX colors used to flag the schema issues.
 * @param {string} [issuesStyles.iconPropertyError] - Custom icon to flag property errors.
 * @param {string} [issuesStyles.colorPropertyError] - Custom HEX color to flag property errors.
 * @param {string} [issuesStyles.iconPropertyMissing] - Custom icon to indicate missing properties.
 * @param {string} [issuesStyles.colorPropertyMissing] - Custom HEX color to indicate missing properties.
 *
 * @returns {Promise<object>} A Promise resolving to an object containing validation results:
 * - `errors`: An array of validation errors as provided by Zod, or `null` if validation passes.
 * - `dataMismatches`: The original response data with all schema mismatches flagged directly.
 *
 */
const validateSchemaZod = async (fixtures, data, schema, issuesStyles) => {
    return _validateSchema('zod', fixtures, data, schema, undefined, issuesStyles);
};
exports.validateSchemaZod = validateSchemaZod;
// **********************************************************************
// PRIVATE FUNCTIONS
// **********************************************************************
const _validateSchema = async (validatorType, fixtures, data, schema, path, issuesStyles) => {
    // Default values (when validation is disabled)
    let validationResult = { errors: null, dataMismatches: data };
    if (process.env.DISABLE_SCHEMA_VALIDATION === 'true') {
        // Schema validation disabled
        console.log(`${warningDisableSchemaValidation} - ${msgDisableSchemaValidation}`);
    }
    else {
        const { page } = fixtures;
        issuesStyles = Object.assign(Object.assign({}, issuesStylesDefault), issuesStyles);
        // Validate the response body against the schema
        validationResult = (validatorType === 'zod') ?
            (0, core_zod_schema_validator_1.validateSchemaZod)(data, schema, issuesStyles) :
            (0, core_ajv_schema_validator_1.validateSchema)(data, schema, path, issuesStyles);
        let { errors, dataMismatches } = validationResult;
        if (!errors) {
            // Schema validation passed
            await test_1.test.step(`${passResponseBodyAgainstSchema}`, async () => {
                console.log(passResponseBodyAgainstSchema);
            });
            (0, test_1.expect)(errors).toBeNull();
        }
        else {
            // Report the issues in the console
            const dataHtml = _transformDataToHtml(dataMismatches, issuesStyles || issuesStylesDefault);
            const html = await _createDataHtmlPage(dataHtml, errors.length, errors);
            await test_1.test.step(`${errorResponseBodyAgainstSchema}`, async () => {
                console.log(errorResponseBodyAgainstSchema);
                console.log('Number of schema errors: ', errors.length);
                console.log('Schema mismatches in data:\n', dataMismatches);
                console.log('Schema errors:\n', errors);
                if (process.env.LOG_API_REPORT === 'true') {
                    test_1.test.info().attach(`${errorResponseBodyAgainstSchema}`, {
                        body: html,
                        contentType: 'text/html'
                    });
                }
            });
            // Report the issues in the PW UI
            if (page && process.env.LOG_API_UI !== 'false') {
                const pageContent = await page.evaluate(async ({ dataHtml, html, errors }) => {
                    var _a;
                    const documentHtml = (_a = document.documentElement) === null || _a === void 0 ? void 0 : _a.innerHTML;
                    if (documentHtml) {
                        if (documentHtml === '' || documentHtml.includes('<head></head><body></body>')) {
                            // Not using pw-api-plugin: page is empty, so set the content to the dataHtml
                            document.documentElement.innerHTML = html;
                        }
                        else {
                            // Using pw-api-plugin: page is not empty, so find the response body element to replace with data mismatches
                            let resBody = document.querySelector('[id^="res-body-"]:last-of-type');
                            if (resBody) {
                                resBody.innerHTML = dataHtml;
                            }
                            let lastTitleLabel = document.querySelector('.pw-api-response:last-of-type label.title-property:last-of-type');
                            if (lastTitleLabel) {
                                lastTitleLabel.innerHTML = lastTitleLabel.innerHTML +
                                    `- <label style="color: #c10000;">Number schema errors: ${errors.length}</label>`;
                            }
                        }
                    }
                }, { dataHtml, html, errors });
            }
            (0, test_1.expect)(errors).toBeNull();
        }
    }
    return validationResult;
};
/**
 * Generates an HTML page string with the provided content embedded in the body.
*
 * @param dataHtml - The HTML content to be included within the body of the generated page.
 * @returns A promise that resolves to a complete HTML page string.
 */
const _createDataHtmlPage = async (dataHtml, numErrors, errors) => {
    return `<html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/${hljsVersion}/styles/vs.min.css"/>
            ${numErrors ? _inlineStyles() : ''}
        </head>
        <body>
            ${errors ? `<h3>Number of schema errors</h3><div class="card total-errors"> ${numErrors}</div>` : ''}
            ${errors ? `<h3>Schema mismatches in data</h3>` : ''}
            ${dataHtml}
            ${errors ? `</div><h3>Schema errors</h3><ul>${errors.map(obj => `<li class="card">${JSON.stringify(obj)}</li>`).join('')}</ul>` : ''}
        </body>
    </html>`;
};
/**
 * Generates a string containing inline CSS styles for an HTML document.
 *
 * @returns {string} A string containing the inline CSS styles.
 */
const _inlineStyles = () => {
    return `<style>
        body { font-family: monospace; margin: 20px; }
        h3 { font-size: 1.5em; margin-bottom: 10px; }
        .card { margin-bottom: 10px; list-style: none; padding: 10px; border: 1px solid #ddd; border-radius: 8px; background-color:rgb(238, 251, 255); text-align: left; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.3); transition: 0.3s;}
        .total-errors { font-size: 1.5em; font-weight: bold; color: #c10000; margin-left: 20px; padding-left: 15px;}
        .total-errors:hover { background-color: rgb(220, 240, 250); }
        .hljs  { text-wrap: wrap; overflow-wrap: break-word;margin-bottom: 10px; padding: 10px; margin-left: 20px; border: 1px solid #ddd; border-radius: 8px; background-color: rgb(238, 251, 255); box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.3); transition: 0.3s;}
        .hljs:hover { background-color: rgb(220, 240, 250); }
        ul { padding-left: 20px; }
        li { font-size: 1.1em; text-wrap: wrap; overflow-wrap: break-word; margin-bottom: 10px; list-style: none; padding: 10px; border: 1px solid #ddd; border-radius: 8px; background-color:rgb(238, 251, 255); text-align: left; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.3); transition: 0.3s;}
        li:hover { background-color: rgb(220, 240, 250); }
    </style>`;
};
/**
 * Transforms a JSON object into an HTML string with syntax highlighting and custom styles for specific issues.
 *
 * @param jsonObject - The JSON object to be transformed into an HTML string.
 * @param issuesStyles - An object containing style configurations for highlighting specific issues.
 * @param issuesStyles.iconPropertyError - The icon property name for errors.
 * @param issuesStyles.colorPropertyError - The color to apply to error properties.
 * @param issuesStyles.iconPropertyMissing - The icon property name for missing fields.
 * @param issuesStyles.colorPropertyMissing - The color to apply to missing fields.
 * @returns An HTML string with syntax-highlighted JSON and custom styles applied to specific issues.
 */
const _transformDataToHtml = (jsonObject, issuesStyles) => {
    const { iconPropertyError, colorPropertyError, iconPropertyMissing, colorPropertyMissing } = issuesStyles;
    const fontStyles = `font-weight: bold; font-size: 1.3em;`;
    let jsonString = JSON.stringify(jsonObject, null, 4);
    let json = highlight_js_1.default.highlight(jsonString, {
        language: 'json',
    }).value;
    // Match either a space or no space between &quot; and the iconPropertyError
    const regexpError = RegExp(`>&quot;\\s*${iconPropertyError}`, 'g');
    json = json.replace(regexpError, (match) => {
        return ` style="${fontStyles}color: ${colorPropertyError};"${match}`;
    });
    const regexpMissing = RegExp(`>&quot;\\s*${iconPropertyMissing}`, 'g');
    json = json.replace(regexpMissing, (match) => {
        return ` style="${fontStyles} color: ${colorPropertyMissing};"${match}`;
    });
    return `<pre class="hljs">${json}</pre>`;
};
